#pragma once

#include <cassert>
#include <cstring>
#include <deque>
#include <memory>
#include <print>
#include <ranges>
#include <utility>

#include "Lexer.hpp"
#include "os/Os.hpp"
#include "Parser.hpp"
#include "Util.hpp"

namespace Interpreter
{

struct [[nodiscard]] Value final
{
    using ValueType = std::variant<std::string_view, std::size_t, std::vector<Value>, std::monostate>;

    Value()
      : value { std::monostate {} }
    {}

    explicit Value(const std::string_view string)
      : value { string }
    {}

    explicit Value(const std::size_t number)
      : value { number }
    {}

    explicit Value(const std::vector<Value>& values)
      : value { values }
    {}

    [[nodiscard]] constexpr auto is_string() const -> bool { return std::holds_alternative<std::string_view>(value); }

    [[nodiscard]] constexpr auto as_string() const -> std::string_view
    {
        return Util::get<std::string_view>(value).value();
    }

    template<std::invocable Callback>
    [[nodiscard]] constexpr auto as_string_or(Callback callback) const -> std::optional<std::string_view>
    {
        return is_string() ? as_string() : callback();
    }

    [[nodiscard]] constexpr auto is_number() const -> bool { return std::holds_alternative<std::size_t>(value); }

    [[nodiscard]] constexpr auto as_number() const -> std::size_t { return Util::get<std::size_t>(value).value(); }

    template<std::invocable Callback>
    [[nodiscard]] constexpr auto as_number_or(Callback callback) const -> std::optional<std::size_t>
    {
        return is_number() ? as_number() : callback();
    }

    [[nodiscard]] constexpr auto is_value_list() const -> bool
    {
        return std::holds_alternative<std::vector<Value>>(value);
    }

    [[nodiscard]] constexpr auto as_value_list() const -> std::vector<Value>
    {
        return Util::get<std::vector<Value>>(value).value();
    }

    template<std::invocable Callback>
    [[nodiscard]] constexpr auto as_value_list_or(Callback callback) const -> std::optional<std::vector<Value>>
    {
        return is_value_list() ? as_value_list() : callback();
    }

    [[nodiscard]] constexpr auto is_monostate() const -> bool { return std::holds_alternative<std::monostate>(value); }

  private:
    ValueType value;
};

template<typename Sim>
class [[nodiscard]] Interpreter final
{
  public:
    [[nodiscard]] static auto eval(const std::string_view file_content, const std::shared_ptr<Sim>& sim) -> bool
    {
        // TODO: introduce flags to disable the verbose output
        // Lex the file
        std::println("--- Lexing file ---");
        const auto tokens = Lexer::lex(file_content);
        if (!tokens) { return false; }

        std::println("- Tokens -");
        for (const auto& [idx, token] : std::views::zip(std::views::iota(0), *tokens)) {
            std::println("#{}: {}", idx, token);
        }

        // Generate AST
        std::println("--- Generating AST ---");
        const auto ast = Parser::parse(*tokens);

        std::println("- Statements -");
        if (!ast) { return false; }
        for (const auto& [idx, statement] : std::views::zip(std::views::iota(0), ast->statements)) {
            std::println("#{}: {}", idx, statement);
        }

        std::println("- Expressions -");
        for (const auto& [idx, expression] : std::views::zip(std::views::iota(0), ast->expressions)) {
            std::println("#{}: {}", idx, expression);
        }

        // Evaluate AST
        Interpreter interpreter(sim, *ast);
        return interpreter.evaluate_ast().has_value();
    }

    [[nodiscard]] auto evaluate_ast() -> std::optional<bool>
    {
        bool failed = false;
        for (const auto& statement : ast.statements) { failed |= TRY(evaluate_statement(statement)); }
        return failed;
    }

    [[nodiscard]] auto evaluate_statement(const Statement& statement) -> std::optional<bool>
    {
        const auto expression_visitor = [this](const StatementKind& kind) -> std::optional<bool> {
            const auto expr_id = TRY(Util::get<ExpressionId>(kind));
            return evaluate_expression(ast.expression_by_id(expr_id)).has_value();
        };

        const auto visitor = Util::make_visitor(expression_visitor);
        return std::visit(visitor, statement.kind);
    }

    [[nodiscard]] auto evaluate_expression(const Expression& expression) -> std::optional<Value>
    {
        const auto call_expression_visitor = [this](const Call& call_expression) -> std::optional<Value> {
            const auto& [name, arguments] = call_expression;
            if (is_builtin(name)) {
                return builtin_handler(name.lexeme, arguments);
            } else {
                assert(false && "not implemented");
            }

            return Value();
        };

        const auto string_literal_visitor = [this](const StringLiteral& string_literal) -> std::optional<Value> {
            return Value(string_literal.literal.lexeme);
        };

        const auto number_visitor = [this](const Number& number) -> std::optional<Value> {
            const auto parsed_number = TRY(Util::parse_number(number.number.lexeme));
            return Value(parsed_number);
        };

        const auto list_visitor = [this](const List& list) -> std::optional<Value> {
            std::vector<Value> result;
            result.reserve(list.elements.size());

            for (const auto& elem : materialize_expressions(list.elements)) {
                result.push_back(TRY(evaluate_expression(elem)));
            }

            return Value(result);
        };


        const auto tuple_visitor = [this](const Tuple& tuple) -> std::optional<Value> {
            std::vector<Value> result;
            result.reserve(tuple.elements.size());

            for (const auto& elem : materialize_expressions(tuple.elements)) {
                result.push_back(TRY(evaluate_expression(elem)));
            }

            return Value(result);
        };

        const auto variable_visitor = [this](const Variable& variable) -> std::optional<Value> {
            return Value(variable.name.lexeme);
        };

        const auto visitor = Util::make_visitor(
          call_expression_visitor, string_literal_visitor, number_visitor, list_visitor, tuple_visitor, variable_visitor
        );
        return std::visit(visitor, expression.kind);
    }

    [[nodiscard]] constexpr static auto is_builtin(const Token& token) -> bool
    {
        constexpr static std::string_view builtins[] = { "spawn_process" };
        return std::ranges::contains(builtins, token.lexeme);
    }

    // FIXME: I'm still not happy with this but it is going in the right direction, i think
    //        we need to figure out a way to do a better error handling, like a report_error helper?
    [[nodiscard]] auto builtin_handler(const std::string_view name, const std::vector<ExpressionId>& arguments)
      -> std::optional<Value>
    {
        // TODO: abstract this in some way later
        if (name == "spawn_process") {
            if (arguments.size() != 4) {
                return report_error(
                  "failed to interpret call to builtin `{}`: expected 4 arguments, {} were provided",
                  name,
                  arguments.size()
                );
            }

            const auto arguments_exprs = materialize_expressions(arguments);

            std::size_t argument_count     = 0;
            const auto  process_name_value = TRY(evaluate_expression(arguments_exprs[argument_count++]));
            const auto  process_name = TRY(process_name_value.as_string_or([&] -> std::optional<std::string_view> {
                return report_error(
                  "mismatched type for argument #{} of builting `{}`: expected type `string`", argument_count - 1, name
                );
            }));

            const auto pid_value = TRY(evaluate_expression(arguments_exprs[argument_count++]));
            const auto pid       = TRY(pid_value.as_number_or([&] -> std::optional<std::size_t> {
                return report_error(
                  "mismatched type for argument #{} of builting `{}`: expected type `int`", argument_count - 1, name
                );
            }));

            const auto arrival_value = TRY(evaluate_expression(arguments_exprs[argument_count++]));
            const auto arrival       = TRY(arrival_value.as_number_or([&] -> std::optional<std::size_t> {
                return report_error(
                  "mismatched type for argument #{} of builting `{}`: expected type `int`", argument_count - 1, name
                );
            }));

            const auto list_value = TRY(evaluate_expression(arguments_exprs[argument_count++]));
            const auto list       = TRY(list_value.as_value_list_or([&] -> std::optional<std::vector<Value>> {
                report_error("mismatched type for argument #{} of builtin `{}`: expected type `List<Tuple: Event>`");
                return report_note("(e.g. [(event_type: `Io` or `Cpu`, duration: int)])");
            }));

            // FIXME: Improve this error handling
            std::deque<Os::Event> events;
            for (const auto& tuple_value : list) {
                const auto tuple = TRY(tuple_value.as_value_list_or([&] -> std::optional<std::vector<Value>> {
                    report_error("mismatched type for argument #{} of builtin `{}`: expected type `List<Tuple: Event>`"
                    );
                    return report_note("(e.g. [(event_type: `Io` or `Cpu`, duration: int)])");
                }));

                const auto event_kind_str = TRY(tuple[0].as_string_or([&] -> std::optional<std::string_view> {
                    report_error("mismatched type for argument #{} of builtin `{}`: expected type `List<Tuple: Event>`"
                    );
                    return report_note("(e.g. [(event_type: `Io` or `Cpu`, duration: int)])");
                }));

                const auto duration = TRY(tuple[1].as_number_or([&] -> std::optional<std::size_t> {
                    report_error("mismatched type for argument #{} of builtin `{}`: expected type `List<Tuple: Event>`"
                    );
                    return report_note("(e.g. [(event_type: `Io` or `Cpu`, duration: int)])");
                }));

                const auto maybe_event_kind = Os::event_kind_try_from_str(event_kind_str);
                if (!maybe_event_kind) {
                    report_error("mismatched type for argument #{} of builtin `{}`: expected type `List<Tuple: Event>`"
                    );
                    return report_note("(e.g. [(event_type: `Io` or `Cpu`, duration: int)])");
                }

                events.push_back(Os::Event { .kind = *maybe_event_kind, .duration = duration });
            }

            sim->emplace_process(process_name, pid, arrival, events);
        }

        return Value();
    }

    template<typename... Args>
    static auto report_error(const std::string_view message, Args&&... args) -> std::nullopt_t
    {
        std::println(stderr, "[ERROR] (interpreter) {}", message, std::forward<Args>(args)...);
    }

    template<typename... Args>
    static auto report_note(const std::string_view message, Args&&... args) -> std::nullopt_t
    {
        std::println(stderr, "[NOTE] (interpreter) {}", message, std::forward<Args>(args)...);
    }

  private:
    explicit Interpreter(const std::shared_ptr<Sim>& sim, Ast ast)
      : sim { sim },
        ast { std::move(ast) }
    {}

    [[nodiscard]] auto materialize_expressions(const std::vector<ExpressionId>& expr_ids) const
      -> std::vector<Expression>
    {
        return std::views::transform(
                 expr_ids, [this](const auto& expr_id) -> Expression { return ast.expression_by_id(expr_id); }
               )
               | std::ranges::to<std::vector>();
    }

    std::shared_ptr<Sim> sim;
    Ast                  ast;
};

} // namespace Interpreter
